--------------------------------------------------------------------------------
Profile data file 'callgrind.out.100' (creator: callgrind-3.16.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 8092806
Trigger: Program termination
Profiled target:  ./main (PID 100, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
37,369,891 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                   file:function
--------------------------------------------------------------------------------

13,602,025 (36.40%)  *  main.c:addWords [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
 9,255,837 (24.77%)  >   ./libio/getc.c:getc (192,153x) [/lib/x86_64-linux-gnu/libc-2.31.so]
 7,195,404 (19.25%)  >   ./malloc/malloc.c:malloc (36,705x) [/lib/x86_64-linux-gnu/libc-2.31.so]
       663 ( 0.00%)  >   ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x) [/lib/x86_64-linux-gnu/ld-2.31.so]

 5,360,168 (14.34%)  *  ./malloc/malloc.c:_int_malloc [/lib/x86_64-linux-gnu/libc-2.31.so]
   146,856 ( 0.39%)  >   ./malloc/malloc.c:alloc_perturb (36,714x) [/lib/x86_64-linux-gnu/libc-2.31.so]
     1,491 ( 0.00%)  >   ./malloc/malloc.c:sysmalloc (9x) [/lib/x86_64-linux-gnu/libc-2.31.so]

 3,622,701 ( 9.69%)  *  main.c:filterBranch'2 [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
 9,147,760 (24.48%)  >   main.c:filterBranch'2 (63,863x) [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]

 3,152,793 ( 8.44%)  *  ./libio/getc.c:getc [/lib/x86_64-linux-gnu/libc-2.31.so]
 6,148,672 (16.45%)  >   ./libio/genops.c:__uflow (32,192x) [/lib/x86_64-linux-gnu/libc-2.31.so]

 2,568,206 ( 6.87%)  *  main.c:validBranch [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]

 2,318,622 ( 6.20%)  *  ./libio/fileops.c:_IO_file_underflow@@GLIBC_2.2.5 [/lib/x86_64-linux-gnu/libc-2.31.so]
   772,872 ( 2.07%)  >   ./libio/genops.c:_IO_switch_to_get_mode (32,203x) [/lib/x86_64-linux-gnu/libc-2.31.so]
   386,436 ( 1.03%)  >   ./libio/fileops.c:_IO_file_read (32,203x) [/lib/x86_64-linux-gnu/libc-2.31.so]
    75,091 ( 0.20%)  >   ./libio/genops.c:_IO_doallocbuf (1x) [/lib/x86_64-linux-gnu/libc-2.31.so]

 1,688,754 ( 4.52%)  *  ./malloc/malloc.c:malloc [/lib/x86_64-linux-gnu/libc-2.31.so]
 5,508,008 (14.74%)  >   ./malloc/malloc.c:_int_malloc (36,712x) [/lib/x86_64-linux-gnu/libc-2.31.so]
    74,949 ( 0.20%)  >   ./malloc/hooks.c:malloc_hook_ini (1x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   901,684 ( 2.41%)  *  ./libio/genops.c:__uflow [/lib/x86_64-linux-gnu/libc-2.31.so]
 5,098,765 (13.64%)  >   ./libio/genops.c:_IO_default_uflow (32,203x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   772,872 ( 2.07%)  *  ./libio/genops.c:_IO_switch_to_get_mode [/lib/x86_64-linux-gnu/libc-2.31.so]

   708,466 ( 1.90%)  *  ./libio/libioP.h:_IO_file_underflow@@GLIBC_2.2.5

   547,451 ( 1.46%)  *  ./libio/genops.c:_IO_default_uflow [/lib/x86_64-linux-gnu/libc-2.31.so]
 4,325,893 (11.58%)  >   ./libio/fileops.c:_IO_file_underflow@@GLIBC_2.2.5 (32,203x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   260,087 ( 0.70%)  *  main.c:compareWords [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
    60,455 ( 0.16%)  >   ./stdio-common/printf.c:printf (113x) [/lib/x86_64-linux-gnu/libc-2.31.so]
     1,647 ( 0.00%)  >   ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x) [/lib/x86_64-linux-gnu/ld-2.31.so]

   225,421 ( 0.60%)  *  ./io/../sysdeps/unix/sysv/linux/read.c:read [/lib/x86_64-linux-gnu/libc-2.31.so]

   225,421 ( 0.60%)  *  ./libio/libioP.h:_IO_default_uflow

   225,421 ( 0.60%)  *  ./libio/libioP.h:__uflow

   170,020 ( 0.45%)  *  main.c:printDictionary'2 [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
 1,469,108 ( 3.93%)  >   main.c:printDictionary'2 (2,669x) [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
   231,855 ( 0.62%)  >   ./libio/ioputs.c:puts (1,493x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   161,015 ( 0.43%)  *  ./libio/fileops.c:_IO_file_read [/lib/x86_64-linux-gnu/libc-2.31.so]
   225,421 ( 0.60%)  >   ./io/../sysdeps/unix/sysv/linux/read.c:read (32,203x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   146,856 ( 0.39%)  *  ./malloc/malloc.c:alloc_perturb [/lib/x86_64-linux-gnu/libc-2.31.so]

   100,954 ( 0.27%)  *  ./libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5 [/lib/x86_64-linux-gnu/libc-2.31.so]
    31,855 ( 0.09%)  >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__mempcpy_avx_unaligned_erms (1,969x) [/lib/x86_64-linux-gnu/libc-2.31.so]
       630 ( 0.00%)  >   ./libio/fileops.c:_IO_file_overflow@@GLIBC_2.2.5 (3x) [/lib/x86_64-linux-gnu/libc-2.31.so]
       206 ( 0.00%)  >   ./libio/genops.c:_IO_default_xsputn (3x) [/lib/x86_64-linux-gnu/libc-2.31.so]

    81,810 ( 0.22%)  *  ./libio/ioputs.c:puts [/lib/x86_64-linux-gnu/libc-2.31.so]
    98,911 ( 0.26%)  >   ./libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5 (1,515x) [/lib/x86_64-linux-gnu/libc-2.31.so]
    22,765 ( 0.06%)  >   ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2 (1,515x) [/lib/x86_64-linux-gnu/libc-2.31.so]

    71,550 ( 0.19%)  *  ./elf/dl-addr.c:_dl_addr [/lib/x86_64-linux-gnu/libc-2.31.so]
       923 ( 0.00%)  >   ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave'2 (1x) [/lib/x86_64-linux-gnu/ld-2.31.so]
         2 ( 0.00%)  >   ./elf/rtld.c:rtld_lock_default_unlock_recursive (1x) [/lib/x86_64-linux-gnu/ld-2.31.so]
         2 ( 0.00%)  >   ./elf/rtld.c:rtld_lock_default_lock_recursive (1x) [/lib/x86_64-linux-gnu/ld-2.31.so]

    64,406 ( 0.17%)  *  ./libio/../sysdeps/unix/sysv/linux/x86/lowlevellock.h:_IO_file_underflow@@GLIBC_2.2.5

    63,155 ( 0.17%)  *  ./stdio-common/vfprintf-internal.c:__vfprintf_internal [/lib/x86_64-linux-gnu/libc-2.31.so]
    34,755 ( 0.09%)  >   ./libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5 (684x) [/lib/x86_64-linux-gnu/libc-2.31.so]
     3,354 ( 0.01%)  >   ./stdio-common/_itoa.c:_itoa_word (114x) [/lib/x86_64-linux-gnu/libc-2.31.so]
     2,166 ( 0.01%)  >   ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strnlen_avx2 (114x) [/lib/x86_64-linux-gnu/libc-2.31.so]

--------------------------------------------------------------------------------
-- Auto-annotated source: main.c
--------------------------------------------------------------------------------
Ir                 

-- line 112 ----------------------------------------
        .           //	utils	//
        .           //////////////
        .           
        .           // - 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z
        .           // 0 1 2 3 4 5 6 7 8 9 101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263
        .           int characterToIndex(char c)
        .           {
        .           	// 11-36
  482,490 ( 1.29%)  	if (c <= 'Z' && c >= 'A')
        .           	{
  160,900 ( 0.43%)  		return c - 'A' + 11;
        .           	}
        .           	// 38-64
  241,140 ( 0.65%)  	else if (c >= 'a' && c <= 'z')
        .           	{
  160,760 ( 0.43%)  		return c - 'a' + 38;
        .           	}
        .           	// 1-10
        .           	else if (c <= '9' && c >= '0')
        .           	{
        .           		return c - '0' + 1;
        .           	}
        .           	// 0
        .           	else if (c == '-')
        .           	{
       10 ( 0.00%)  		return 0;
        .           	}
        .           	// 37
        .           	return 37;
        .           }
        .           char indexToCharacter(int n)
        .           {
        .           	// 11-36
   10,760 ( 0.03%)  	if (n <= 36 && n >= 11)
        .           	{
      987 ( 0.00%)  		return n + 'A' - 11;
        .           	}
        .           	// 38-64
    5,109 ( 0.01%)  	else if (n >= 38 && n <= 63)
        .           	{
    3,406 ( 0.01%)  		return n + 'a' - 38;
        .           	}
        .           	// 1-10
        .           	else if (n <= 10 && n >= 1)
        .           	{
        .           		return n + '0' - 1;
        .           	}
        .           	// 0
        .           	else if (n == 0)
-- line 160 ----------------------------------------
-- line 168 ----------------------------------------
        .           {
        .           	short unsigned int i;
        .           	tree_t *treeCursor;
        .           	tree_t *rightChild;
        .           
        .           	treeCursor = head;
        .           
        .           	// scorro la parola inserita
    2,977 ( 0.01%)  	for (i = 0; i < info->length; i++)
        .           	{
        .           		// trovo il figlio, devo pure aggiornare l'head nel caso cambi
    1,310 ( 0.00%)  		rightChild = findChild(treeCursor->child, info->word[i]);
        .           		// se lo trovo proseguo la scansione
        .           		if (rightChild)
        .           			// sposto il cursore nel figlio trovato
        .           			treeCursor = rightChild;
        .           		else
        .           			// se non lo trovo termino ritornando 0
       12 ( 0.00%)  			return 0;
        .           	}
      238 ( 0.00%)  	return 1;
       12 ( 0.00%)  }
        .           
        .           //////////////
        .           //	alberi	//
        .           //////////////
        .           tree_t *addNode(tree_t *h, int c)
        4 ( 0.00%)  {
        .           	// adding node
        8 ( 0.00%)  	h = (tree_t *)malloc(sizeof(tree_t));
      831 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        2 ( 0.00%)  	if (h)
        .           	{
        3 ( 0.00%)  		h->index = c;
        .           		h->valid = 1;
        1 ( 0.00%)  		h->child = NULL;
        .           	}
        .           	else
        .           	{
        .           		printf("memory error");
        .           	}
        .           	return h;
        5 ( 0.00%)  }
        .           tree_t *addWord(info_t *info, tree_t *head)
        .           {
        .           	short unsigned int i;
        .           	tree_t *treeCursor;
        .           	tree_t *rightChild;
        .           
   32,025 ( 0.09%)  	treeCursor = head;
        .           
        .           	// scorro la parola inserita
1,184,925 ( 3.17%)  	for (i = 0; i < info->length; i++)
        .           	{
        .           		// trovo il figlio o lo aggiungo se non c'è, devo pure aggiornare l'head nel caso cambi
  640,500 ( 1.71%)  		treeCursor->child = findOrAddChild(treeCursor->child, info->word[i], &rightChild);
        .           		// sposto il cursore nel figlio (che sia stato appena aggiunto o meno è indifferente)
        .           		treeCursor = rightChild;
        .           	}
        .           	return head;
        .           }
        .           tree_t *addWords(info_t *info, tree_t *head)
       30 ( 0.00%)  {
        .           	// printf("\n----inizio inserimento----\n");
        .           	short unsigned int i, j;
        .           	char character;
        .           	// prendi primo carattere
        .           	do
        .           	{
       16 ( 0.00%)  		character = getc(stdin);
      612 ( 0.00%)  => ./libio/getc.c:getc (3x)
      663 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       16 ( 0.00%)  	} while (character == EOS || character == EOL || character == EOW);
        .           
        .           	// mentre non ricevo nuovi comandi
   64,059 ( 0.17%)  	for (i = 0; character != '+'; i++)
        .           	{
        .           		// acquisisco la parola al contrario
1,377,075 ( 3.68%)  		for (j = 0; j < info->length; j++)
        .           		{
  640,500 ( 1.71%)  			info->word[j] = characterToIndex(character);
  480,375 ( 1.29%)  			character = getc(stdin);
2,722,125 ( 7.28%)  => ./libio/getc.c:getc (160,125x)
        .           		}
        .           		// la aggiungo al dizionario
        .           		addWord(info, head);
        .           		// prendi primo carattere della prossima riga
   96,075 ( 0.26%)  		character = getc(stdin);
6,533,100 (17.48%)  => ./libio/getc.c:getc (32,025x)
        .           	}
        .           	// printf("\n----fine inserimento----\n");
        .           
        .           	return head;
       27 ( 0.00%)  }
        .           // rende valido l'elemento che gli viene passato e tutti i suoi figli
        .           void validBranch(tree_t *h)
       80 ( 0.00%)  {
        .           	tree_t *listCursor;
        .           
        .           	// All the children
2,201,178 ( 5.89%)  	for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
        .           		validBranch(listCursor);
        .           
  366,868 ( 0.98%)  	h->valid = 1;
       80 ( 0.00%)  }
        .           
        .           //////////////
        .           //	liste	//
        .           //////////////
        .           
        .           // unica funzione che aggiunge il figlio se non c'è
        .           // oppure ritorna l'indirizzo del figlio se c'è
        .           tree_t *findOrAddChild(tree_t *h, int c, tree_t **found)
        .           {
        .           	tree_t *cursor, *previous;
  160,125 ( 0.43%)  	previous = NULL;
        .           	// sposto il cursore fino a trovare il figlio che punta a un nodo il cui carattere è maggiore o uguale di quello desiderato
6,736,441 (18.03%)  	for (cursor = h; cursor != NULL && cursor->index < c; cursor = cursor->nextSibiling)
        .           		previous = cursor;
        .           	// se non lo trovo lo aggiungo
  147,510 ( 0.39%)  	if (cursor == NULL || cursor->index > c)
        .           	{
        .           		cursor = addChildBetween(previous, cursor, c);
        .           	}
        .           	// se il precedente è null, ho aggiunto all'inizio della lista cambiando l'head
  402,670 ( 1.08%)  	if (previous == NULL)
        .           	{
        .           		h = cursor;
        .           	}
        .           	// in ogni caso ritorno cursor, se non l' ho aggiunto significa che:
        .           	// cursor != NULL && cursor->node->character == c
        .           	*found = cursor;
        .           	return h;
        .           }
        .           // aggiunge elemento alla lista tra precedente e prossimo
        .           tree_t *addChildBetween(tree_t *last, tree_t *next, int c)
        .           {
        .           	tree_t *newChild;
        .           
  151,501 ( 0.41%)  	newChild = (tree_t *)malloc(sizeof(tree_t));
7,195,404 (19.25%)  => ./malloc/malloc.c:malloc (36,705x)
        .           	// adding node
  110,115 ( 0.29%)  	if (newChild)
        .           	{
   36,705 ( 0.10%)  		newChild->nextSibiling = next;
   73,410 ( 0.20%)  		newChild->index = c;
    4,681 ( 0.01%)  		newChild->valid = 1;
   41,386 ( 0.11%)  		newChild->child = NULL;
        .           		// se c'era effettivamente un nodo prima di newChild
   84,401 ( 0.23%)  		if (last)
        .           		{
   96,556 ( 0.26%)  			last->nextSibiling = newChild;
        .           		}
        .           	}
        .           	else
        .           	{
        .           		printf("memory error");
        .           	}
        .           	return newChild;
        .           }
        .           // trova e ritorna l'indirizzo del figlio se c'è, altrimenti ritorna null
        .           tree_t *findChild(tree_t *h, int c)
        .           {
        .           	tree_t *cursor;
        .           	// sposto il cursore fino a trovare il figlio che punta a un nodo il cui carattere è maggiore o uguale di quello desiderato
   23,708 ( 0.06%)  	for (cursor = h; cursor != NULL && cursor->index < c; cursor = cursor->nextSibiling)
        .           		;
        .           	// se non lo trovo ritorno null, non serve scorrerli tutti
      652 ( 0.00%)  	if (cursor == NULL || cursor->index > c)
        .           	{
        .           		cursor = NULL;
        .           	}
        .           	// in ogni caso ritorno cursor
        .           	return cursor;
        .           }
        .           ////////////////////
        .           //	CLOSE TO I/O  //
-- line 338 ----------------------------------------
-- line 340 ----------------------------------------
        .           void filterDictionary(info_t *info, tree_t *h)
        .           {
        .           	tree_t *listCursor;
        .           
        .           	int i;
        .           	// inizializzo il contatore di caratteri a zero
        .           	for (i = 0; i < ALPH_LEN; i++)
        .           	{
    2,954 ( 0.01%)  		info->characterCounter[i] = 0;
        .           	}
        .           	// inizializzo il numero di lettere che hanno abbastanza occorrenze
        .           	info->lettersWithEnoughOccurrences = 0;
        .           	// filtro il dizionario aggiornando i validi
      288 ( 0.00%)  	info->depth = -1;
        .           	// inizializzo il contatore delle filtrate a zero
       72 ( 0.00%)  	info->filteredCounter = 0;
    1,944 ( 0.01%)  	for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
    1,152 ( 0.00%)  		if (listCursor->valid)
      705 ( 0.00%)  			filterBranch(info, listCursor);
3,642,991 ( 9.75%)  => main.c:filterBranch (235x)
        .           
        .           	// è tutto uptodate
       72 ( 0.00%)  	info->isDiscoveredOccurrencesUTD = 1;
       72 ( 0.00%)  	info->isIsPositionOfCharacterValidUTD = 1;
       72 ( 0.00%)  	info->isIsDefinitiveUTD = 1;
        2 ( 0.00%)  }
        .           void filterBranch(info_t *info, tree_t *h)
  324,390 ( 0.87%)  {
        .           	tree_t *listCursor;
        .           
        .           	// conto i caratteri
  519,024 ( 1.39%)  	info->characterCounter[h->index]++;
        .           	// se il numero di una lettera supera il numero effettivo di occorrenze (e si è certi del numero)
  307,456 ( 0.82%)  	if (info->characterCounter[h->index] > info->discoveredOccurrences[h->index] && info->isDefinitive[h->index])
        .           	{
        .           		// rendo non valido il nodo
      441 ( 0.00%)  		h->valid = 0;
        .           	}
        .           	else
        .           	{
        .           		// aumento la profondità
  644,370 ( 1.72%)  		info->depth++;
        .           		// se il carattere non si può trovare a quella posizione (profondità)
  322,185 ( 0.86%)  		if (!(info->isPositionOfCharacterValid[info->depth][h->index]))
        .           		{
        .           			// rendo non valido il nodo
   27,514 ( 0.07%)  			h->valid = 0;
        .           		}
        .           		else
        .           		{
        .           			// conto le lettere con abbastanza occorrenze
   13,896 ( 0.04%)  			if (info->characterCounter[h->index] == info->discoveredOccurrences[h->index])
        .           			{
    6,778 ( 0.02%)  				info->lettersWithEnoughOccurrences++;
        .           			}
        .           			// quando raggiungo la fine della parola
  133,660 ( 0.36%)  			if (h->child == NULL)
        .           			{
  166,764 ( 0.45%)  				if (info->lettersWithEnoughOccurrences == info->numberOfDiscoveredOccurrences)
        .           				{
        .           					// conto la filtrata
   19,856 ( 0.05%)  					info->filteredCounter++;
        .           				}
        .           				else
        .           				{
        .           					// rendo non valido il branch dalla radice morta in su e decremento i contatori
   35,732 ( 0.10%)  					h->valid = 0;
        .           				}
        .           			}
        .           			// All the valid children
  215,442 ( 0.58%)  			for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
  143,628 ( 0.38%)  				if (listCursor->valid)
  193,929 ( 0.52%)  					filterBranch(info, listCursor);
3,622,701 ( 9.69%)  => main.c:filterBranch'2 (780x)
        .           			;
        .           			// se il contatore della lettera, che mi garantiva che ci fossero abbastanza
        .           			// occorrenze della lettera stessa, va sotto la soglia, non ci sono più abbastanza occorrenze
  156,414 ( 0.42%)  			if (info->characterCounter[h->index] == info->discoveredOccurrences[h->index])
        .           			{
   13,556 ( 0.04%)  				info->lettersWithEnoughOccurrences--;
        .           			}
        .           		}
        .           		// al ritorno decremento la profondità
   64,437 ( 0.17%)  		info->depth--;
        .           	}
        .           	// al ritorno decremento la lettera
   74,007 ( 0.20%)  	info->characterCounter[h->index]--;
  259,512 ( 0.69%)  }
        .           //////////////
        .           //	I/O	    //
        .           //////////////
        .           void printDictionary(info_t *info, tree_t *h)
   10,804 ( 0.03%)  {
        .           	tree_t *listCursor;
   13,505 ( 0.04%)  	if (h->index != -1)
        .           	{
   26,900 ( 0.07%)  		info->depth++;
        .           		// posiziona il carattere nella parola contenitore
   13,450 ( 0.04%)  		info->result[info->depth] = indexToCharacter(h->index);
        .           
        .           		// printf("%c, %d\n", h->character, h->valid);
        .           
        .           		// stampa la parola quando raggiungi la fine
    8,070 ( 0.02%)  		if (h->child == NULL)
    5,972 ( 0.02%)  			puts(info->result);
  231,855 ( 0.62%)  => ./libio/ioputs.c:puts (1,493x)
        .           		else
        .           			// All the children
   28,218 ( 0.08%)  			for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
   18,812 ( 0.05%)  				if (listCursor->valid)
   10,676 ( 0.03%)  					printDictionary(info, listCursor);
1,469,108 ( 3.93%)  => main.c:printDictionary'2 (2,669x)
    2,690 ( 0.01%)  		info->depth--;
        .           	}
        .           	else
        .           	{
       11 ( 0.00%)  		info->depth = -1;
       44 ( 0.00%)  		info->word[info->length - 1] = EOS;
        .           		// All the children
      297 ( 0.00%)  		for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
      183 ( 0.00%)  			if (listCursor->valid)
       84 ( 0.00%)  				printDictionary(info, listCursor);
  401,875 ( 1.08%)  => main.c:printDictionary'2 (21x)
        .           	}
   10,804 ( 0.03%)  }
        .           void compareWords(info_t *info, _Bool *isFree)
      684 ( 0.00%)  {
        .           	short unsigned int i, j, found, definitive;
        .           
    5,244 ( 0.01%)  	for (i = 0; i < info->length; i++)
        .           	{
    2,850 ( 0.01%)  		if (info->word[i] == info->solution[i])
        .           		{
        .           			// giusta al posto giusto
    1,422 ( 0.00%)  			info->result[i] = '+';
        .           			// segno che è già stata associata
      282 ( 0.00%)  			isFree[i] = 0;
        .           			// metto a zero tutti i caratteri (nessuno è valido tranne quello giusto al posto giusto)
   54,144 ( 0.14%)  			for (j = 0; j < ALPH_LEN; j++)
        .           			{
        .           				// se non l'avevo precedentemente messo a zero lo azzero, ovviamente ciò non vale per quello giusto al posto giusto
   43,776 ( 0.12%)  				if (info->isPositionOfCharacterValid[i][j] == 1 && j != info->word[i])
        .           				{
        .           					// azzero la posizione (non è valida)
    2,853 ( 0.01%)  					info->isPositionOfCharacterValid[i][j] = 0;
        .           					// segno che sono cambiate le posizioni
    2,853 ( 0.01%)  					info->isIsPositionOfCharacterValidUTD = 0;
        .           				}
        .           			}
        .           			// conto la lettera
      564 ( 0.00%)  			info->characterCounter[info->word[i]]++;
        .           		}
        .           		else
        .           		{
        .           			// per ora non è stata trovata
      288 ( 0.00%)  			info->result[i] = '/';
        .           			// non è associata
      288 ( 0.00%)  			isFree[i] = 1;
        .           			// i caratteri che non sono risultati giusti al posto giusto
        .           			// controllo il valore (vedo se sono già rimossi)
    1,440 ( 0.00%)  			if (info->isPositionOfCharacterValid[i][info->word[i]] == 1)
        .           			{
        .           				// se non lo sono li rimuovo
       82 ( 0.00%)  				info->isPositionOfCharacterValid[i][info->word[i]] = 0;
        .           				// segno che sono cambiate le posizioni
       82 ( 0.00%)  				info->isIsPositionOfCharacterValidUTD = 0;
        .           			}
        .           		}
        .           	}
    2,052 ( 0.01%)  	for (i = 0; i < info->length; i++)
        .           	{
      570 ( 0.00%)  		definitive = 0;
        .           		found = 0;
    8,086 ( 0.02%)  		for (j = 0; j < info->length && !found; j++)
        .           		{
        .           			// controllo se esiste una uguale non associata e non fissata (ancora '/' e non '+')
   16,131 ( 0.04%)  			if (info->word[i] == info->solution[j] && info->result[i] != '+')
        .           			{
        .           				// se trovo una non associata
      384 ( 0.00%)  				if (isFree[j])
        .           				{
        .           					// trovata, devo passare alla prossima lettera
        .           					// anche per non contare le altre
        .           					found = 1;
        .           					// giusta al posto sbagliato
       77 ( 0.00%)  					info->result[i] = '|';
        .           					// conto le lettere
      308 ( 0.00%)  					info->characterCounter[info->word[i]]++;
        .           					// segno che è già stata associata
       77 ( 0.00%)  					isFree[j] = 0;
        .           					// se prima pensavo fosse definitiva ho scoperto che non lo è
        .           					definitive = 0;
        .           				}
        .           				// potrei trovare una da associare dopo, ma se non la trovassi avrei le occorrenze definitive
        .           				else
        .           				{
       51 ( 0.00%)  					definitive = 1;
        .           				}
        .           			}
        .           		}
      978 ( 0.00%)  		if (definitive)
        .           		{
        .           			// se nin è già definitiva
      102 ( 0.00%)  			if (info->isDefinitive[info->word[i]] == 0)
        .           			{
        .           				// metto il numero corretto di occorrenze
       42 ( 0.00%)  				info->discoveredOccurrences[info->word[i]] = info->trueOccurrences[info->word[i]];
        .           				// segno che è definitivo
       21 ( 0.00%)  				info->isDefinitive[info->word[i]] = 1;
        .           				// segno che sono variati i definitivi
       42 ( 0.00%)  				info->isIsDefinitiveUTD = 0;
        .           			}
        .           		}
        .           		// controllo se viene trovata
        .           		found = 0;
    4,458 ( 0.01%)  		for (j = 0; j < info->length && !found; j++)
        .           		{
        .           			// controllo se viene trovata
    3,779 ( 0.01%)  			if (info->word[i] == info->solution[j])
        .           			{
        .           				// segno che è stata trovata e posso uscire dal ciclo
        .           				found = 1;
        .           			}
        .           		}
        .           		// se questo è vero, è proprio sbagliata!!, la rimuovo in toto (da ogni posizione)
        .           		if (!found)
        .           		{
   10,076 ( 0.03%)  			for (j = 0; j < info->length; j++)
        .           			{
        .           				// controllo se la posizione è ancora valida
    2,655 ( 0.01%)  				if (info->isPositionOfCharacterValid[j][info->word[i]] == 1)
        .           				{
        .           					// se lo è la rendo non valida
      103 ( 0.00%)  					info->isPositionOfCharacterValid[j][info->word[i]] = 0;
        .           					// segno che sono variate le posizioni
      206 ( 0.00%)  					info->isIsPositionOfCharacterValidUTD = 0;
        .           				}
        .           			}
        .           		}
        .           	}
      114 ( 0.00%)  	info->numberOfDiscoveredOccurrences = 0;
        .           	// aggiorno le occorrenze che non sono già definitive
   22,572 ( 0.06%)  	for (int i = 0; i < ALPH_LEN; i++)
        .           	{
        .           		// se non ho già stabilito il numero definitivo di occorrenze per questa lettera
   14,592 ( 0.04%)  		if (!(info->isDefinitive[i]))
        .           		{
        .           			// non c'è pericolo di contare più occorrenze di quelle massime
        .           			// ogni volta controllo se è stata associata la lettera
   35,988 ( 0.10%)  			if (info->characterCounter[i] > info->discoveredOccurrences[i])
        .           			{
        .           				// aggiorno il minimo di occorrenze
       38 ( 0.00%)  				info->discoveredOccurrences[i] = info->characterCounter[i];
        .           				// segno che sono variate le occorrenze
       38 ( 0.00%)  				info->isDiscoveredOccurrencesUTD = 0;
        .           			}
        .           		}
        .           		// aggiorno il numero di occorrenze scoperte
   14,630 ( 0.04%)  		if (info->discoveredOccurrences[i] > 0)
        .           		{
    2,094 ( 0.01%)  			info->numberOfDiscoveredOccurrences++;
        .           		}
        .           	}
        .           	// stampa risultato del confronto
    2,287 ( 0.01%)  	printf("%.*s\n", info->length, info->result);
   60,455 ( 0.16%)  => ./stdio-common/printf.c:printf (113x)
    1,647 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           
        .           	// mostro caratteri che posso trovare alle posizioni
        .           	/*
        .           		for (i = 0; i < info->length; i++)
        .           		{
        .           			for (j = 0; j < ALPH_LEN; j++)
        .           				printf("-%d-", info->isPositionOfCharacterValid[i][j]);
        .           			printf("\n");
-- line 607 ----------------------------------------
-- line 628 ----------------------------------------
        .           			printf("%d", info->trueOccurrences[i]);
        .           		}
        .           		printf("\n");
        .           		printf("\number of discovered\n");
        .           		printf("%d", info->numberOfDiscoveredOccurrences);
        .           		printf("\n");
        .           	*/
        .           	return;
      684 ( 0.00%)  }
        .           void startMatch(info_t *info, tree_t *head, _Bool *isFree)
      120 ( 0.00%)  {
        .           	short unsigned int i, j, attempts;
        .           	char character;
        .           	char command[MAX_COMMAND_LENGTH];
        .           
        .           	//  prendo la soluzione
      270 ( 0.00%)  	for (i = 0; i < info->length; i++)
      350 ( 0.00%)  		info->solution[i] = characterToIndex(getc(stdin));
    2,720 ( 0.01%)  => ./libio/getc.c:getc (50x)
        .           	// prendo il null
       30 ( 0.00%)  	character = getc(stdin);
      170 ( 0.00%)  => ./libio/getc.c:getc (10x)
        .           	// scan per sapere quanti tentativi ho a disposizione in questa partita
       60 ( 0.00%)  	if (scanf("%hd", &attempts))
    7,792 ( 0.02%)  => ./stdio-common/isoc99_scanf.c:__isoc99_scanf (10x)
        .           		;
        .           	//  prendi primo carattere
        .           	do
        .           	{
       60 ( 0.00%)  		character = getc(stdin);
    2,210 ( 0.01%)  => ./libio/getc.c:getc (20x)
       80 ( 0.00%)  	} while (character == EOS || character == EOL || character == EOW);
        .           
        .           	// inizializzo i caratteri che posso trovare alle posizioni
      350 ( 0.00%)  	for (i = 0; i < info->length; i++)
        .           		for (j = 0; j < ALPH_LEN; j++)
      250 ( 0.00%)  			info->isPositionOfCharacterValid[i][j] = 1;
        .           	// inizializzo il numero di caratteri trovati
        .           	for (i = 0; i < ALPH_LEN; i++)
       50 ( 0.00%)  		info->discoveredOccurrences[i] = 0;
        .           	// inizializzo il numero di caratteri della soluzione
        .           	for (i = 0; i < ALPH_LEN; i++)
       40 ( 0.00%)  		info->trueOccurrences[i] = 0;
        .           	// conto i caratteri della soluzione
      270 ( 0.00%)  	for (i = 0; i < info->length; i++)
      100 ( 0.00%)  		info->trueOccurrences[info->solution[i]]++;
        .           	// inizializzo i definitivi
        .           	for (i = 0; i < ALPH_LEN; i++)
       50 ( 0.00%)  		info->isDefinitive[i] = 0;
        .           	// inizializzo le occorrenze scoperte
       10 ( 0.00%)  	info->numberOfDiscoveredOccurrences = 0;
        .           
        .           	// le parole provate sono minori del numero di tentativi
       10 ( 0.00%)  	i = 0;
      288 ( 0.00%)  	while (i < attempts)
        .           	{
        .           		// controllo se ho ricevuto comandi durante una partita
      288 ( 0.00%)  		if (character == '+')
        .           		{
       78 ( 0.00%)  			if (fgets(command, MAX_COMMAND_LENGTH, stdin))
    2,197 ( 0.01%)  => ./libio/iofgets.c:fgets (13x)
        .           				;
        .           			// comando per stampare filtrate durante una partita
      110 ( 0.00%)  			if (strcmp(command, "stampa_filtrate\n") == 0)
        .           			{
        .           				// printf("\n---printing_dictionary---\n");
       44 ( 0.00%)  				printDictionary(info, head);
  402,637 ( 1.08%)  => main.c:printDictionary (11x)
        .           			}
        .           			// comando per aggiungere parole al dizionario durante una partita
       16 ( 0.00%)  			else if (strcmp(command, "inserisci_inizio\n") == 0)
        .           			{
       10 ( 0.00%)  				head = addWords(info, head);
   23,767 ( 0.06%)  => main.c:addWords (2x)
        .           				// devo "buttare" la parte finale di comando ("inserisci fine")
       10 ( 0.00%)  				if (fgets(command, MAX_COMMAND_LENGTH, stdin))
      342 ( 0.00%)  => ./libio/iofgets.c:fgets (2x)
        .           					;
        .           				filterDictionary(info, head);
        .           			}
        .           		}
        .           		else
        .           		{
        .           			// acquisisco la parola
    3,799 ( 0.01%)  			for (j = 0; j < info->length; j++)
        .           			{
    2,620 ( 0.01%)  				info->word[j] = characterToIndex(character);
    1,965 ( 0.01%)  				character = getc(stdin);
   11,135 ( 0.03%)  => ./libio/getc.c:getc (655x)
        .           			}
        .           			// controllo se la parola è presente nel dizionario
      655 ( 0.00%)  			if (findWord(info, head))
   28,909 ( 0.08%)  => main.c:findWord (131x)
        .           			{
        .           				// incremento il contatore di tentativi (valgono solo i tentativi validi)
      114 ( 0.00%)  				i++;
        .           				// vedo se la parola per caso è giusta
    1,057 ( 0.00%)  				for (j = 0; info->word[j] == info->solution[j]; j++)
      416 ( 0.00%)  					if (j == info->length)
        .           					{
       15 ( 0.00%)  						puts("ok");
      825 ( 0.00%)  => ./libio/ioputs.c:puts (5x)
       10 ( 0.00%)  						validBranch(head);
1,284,152 ( 3.44%)  => main.c:validBranch (5x)
        .           						return;
        .           					}
        .           				// inizializzo il contatore di caratteri a zero
        .           				for (j = 0; j < ALPH_LEN; j++)
        .           				{
    4,674 ( 0.01%)  					info->characterCounter[j] = 0;
        .           				}
        .           				// inizializzo i free
    3,306 ( 0.01%)  				for (j = 0; j < info->length; j++)
      798 ( 0.00%)  					isFree[i] = 0;
        .           				// paragono la parola alla soluzione, stampo il risultato del confronto e aggiorno info
      456 ( 0.00%)  				compareWords(info, isFree);
  322,189 ( 0.86%)  => main.c:compareWords (114x)
        .           
      626 ( 0.00%)  				if (info->isDiscoveredOccurrencesUTD && info->isIsPositionOfCharacterValidUTD && info->isIsDefinitiveUTD)
        .           				{
        .           				}
        .           				else
        .           				{
        .           					filterDictionary(info, head);
        .           				}
        .           				// stampa numero di parole rimaste
      728 ( 0.00%)  				printf("%d\n", info->filteredCounter);
   64,013 ( 0.17%)  => ./stdio-common/printf.c:printf (114x)
        .           			}
        .           			else
        .           			{
       40 ( 0.00%)  				puts("not_exists");
    1,683 ( 0.00%)  => ./libio/ioputs.c:puts (11x)
      812 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           			}
        .           		}
        .           		// se ho tentativi rimanenti
      278 ( 0.00%)  		if (i < attempts)
        .           			// prendi primo carattere della prossima riga
      402 ( 0.00%)  			character = getc(stdin);
   27,336 ( 0.07%)  => ./libio/getc.c:getc (134x)
        .           	}
        .           	if (i >= attempts)
        .           	{
        .           		// printf("ultimo car: %c\n", character);
       15 ( 0.00%)  		puts("ko");
      785 ( 0.00%)  => ./libio/ioputs.c:puts (5x)
       10 ( 0.00%)  		validBranch(head);
1,284,054 ( 3.44%)  => main.c:validBranch (5x)
        .           	}
        .           
        .           	return;
       80 ( 0.00%)  }
        .           int main(int argc, char *argv[])
        7 ( 0.00%)  {
        .           	short unsigned int wordLength;
        .           	info_t infoVar;
        .           	tree_t *dictionary = NULL;
        .           	char character;
        .           	_Bool *isFree;
        .           	char command[MAX_COMMAND_LENGTH + 1];
        .           	/*
        .           		printf("%ld\n", sizeof(int));
        .           		printf("%ld\n", sizeof(tree_t));
        .           		printf("%ld\n", sizeof(tree_t *));
        .           	*/
        .           	// scan per sapere quanto è lunga la parola
        9 ( 0.00%)  	if (scanf("%hd", &wordLength))
   76,509 ( 0.20%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           		;
        6 ( 0.00%)  	infoVar.length = wordLength;
        .           	// creo dizionario vuoto
        4 ( 0.00%)  	dictionary = addNode(dictionary, -1);
      854 ( 0.00%)  => main.c:addNode (1x)
        .           
        .           	// creo vettore di vettori statici
        7 ( 0.00%)  	infoVar.isPositionOfCharacterValid = malloc(sizeof(_Bool) * wordLength * ALPH_LEN);
      191 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creating array where to put infoVar.word
        8 ( 0.00%)  	infoVar.word = (int *)malloc(7 * wordLength);
      196 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creo vettore dove mettere la soluione
        5 ( 0.00%)  	infoVar.solution = (int *)malloc(7 * wordLength);
      196 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creo vettore dove mettere il risultato del confronto
        5 ( 0.00%)  	infoVar.result = (char *)malloc(sizeof(char) * wordLength);
      189 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creating array where to put check for pairing
        5 ( 0.00%)  	isFree = (_Bool *)malloc(sizeof(_Bool) * wordLength);
      189 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           
       14 ( 0.00%)  	if (infoVar.word && infoVar.solution && infoVar.result && isFree && infoVar.isPositionOfCharacterValid)
        .           	{
        .           		// aggiungo per la prima volta parole al dizionario
        6 ( 0.00%)  		dictionary = addWords(&infoVar, dictionary);
30,030,162 (80.36%)  => main.c:addWords (1x)
        .           
        .           		// sicuramente ho terminato con un comando
        .           		// il carattere '+' con cui inizia il comando nuova_partita è stato mangiato da addWords che lo ha "scambiato" per il '+' di inserisci_fine
        .           		character = '+';
        .           		// se non sono in una partita e non sto aggiungendo parole, posso solo ricevere comandi, ma controlliamo ugualmente per sicurezza
       21 ( 0.00%)  		while (character == '+')
        .           		{
       54 ( 0.00%)  			if (fgets(command, MAX_COMMAND_LENGTH, stdin))
      797 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
    1,539 ( 0.00%)  => ./libio/iofgets.c:fgets (9x)
        .           				;
        .           			// printf("\ncomando: %s", command);
        .           			//  comando per iniziare una partita
       81 ( 0.00%)  			if (strcmp(command, "nuova_partita\n") == 0)
        .           			{
       50 ( 0.00%)  				startMatch(&infoVar, dictionary, isFree);
7,147,459 (19.13%)  => main.c:startMatch (10x)
        .           			}
        .           			// comando per aggiungere parole al dizionario tra una partita e l'altra
        2 ( 0.00%)  			else if (strcmp(command, "inserisci_inizio\n") == 0)
        .           			{
        .           				dictionary = addWords(&infoVar, dictionary);
        .           				// devo "buttare" la parte finale di comando ("inserisci fine")
        .           				if (fgets(command, MAX_COMMAND_LENGTH, stdin))
        .           					;
        .           			}
        .           			// prendi primo carattere (tendenzialmente sarà un '+'), se non lo è termino l'esecuzione (sarà un \n)
       30 ( 0.00%)  			character = getc(stdin);
    2,040 ( 0.01%)  => ./libio/getc.c:getc (10x)
        .           		}
        .           	}
        .           	else
        .           	{
        .           		printf("memory error");
        .           	}
        .           
        .           	return 0;
        9 ( 0.00%)  }
--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/dl-addr.c
  ./io/../sysdeps/unix/sysv/linux/read.c
  ./libio/../sysdeps/unix/sysv/linux/x86/lowlevellock.h
  ./libio/fileops.c
  ./libio/genops.c
  ./libio/getc.c
  ./libio/ioputs.c
  ./libio/libioP.h
  ./malloc/malloc.c
  ./stdio-common/vfprintf-internal.c

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
20,310,086 (54.35%)  events annotated

