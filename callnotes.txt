--------------------------------------------------------------------------------
Profile data file 'callgrind.out.4875' (creator: callgrind-3.16.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 8193229
Trigger: Program termination
Profiled target:  ./main (PID 4875, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
38,911,527 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                   file:function
--------------------------------------------------------------------------------

10,711,747 (27.53%)  *  ./malloc/malloc.c:_int_malloc [/lib/x86_64-linux-gnu/libc-2.31.so]
   293,476 ( 0.75%)  >   ./malloc/malloc.c:alloc_perturb (73,369x) [/lib/x86_64-linux-gnu/libc-2.31.so]
     2,913 ( 0.01%)  >   ./malloc/malloc.c:sysmalloc (18x) [/lib/x86_64-linux-gnu/libc-2.31.so]

 8,316,311 (21.37%)  *  main.c:findOrAddChild [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
15,982,516 (41.07%)  >   main.c:addChildBetween (36,680x) [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]

 3,488,044 ( 8.96%)  *  main.c:addWords [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
24,298,827 (62.45%)  >   main.c:findOrAddChild (160,000x) [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
 9,248,204 (23.77%)  >   ./libio/getc.c:getc (192,001x) [/lib/x86_64-linux-gnu/libc-2.31.so]
       663 ( 0.00%)  >   ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x) [/lib/x86_64-linux-gnu/ld-2.31.so]

 3,374,876 ( 8.67%)  *  ./malloc/malloc.c:malloc [/lib/x86_64-linux-gnu/libc-2.31.so]
11,007,629 (28.29%)  >   ./malloc/malloc.c:_int_malloc (73,367x) [/lib/x86_64-linux-gnu/libc-2.31.so]
    74,949 ( 0.19%)  >   ./malloc/hooks.c:malloc_hook_ini (1x) [/lib/x86_64-linux-gnu/libc-2.31.so]

 3,137,266 ( 8.06%)  *  ./libio/getc.c:getc [/lib/x86_64-linux-gnu/libc-2.31.so]
 6,114,865 (15.71%)  >   ./libio/genops.c:__uflow (32,015x) [/lib/x86_64-linux-gnu/libc-2.31.so]

 2,305,302 ( 5.92%)  *  ./libio/fileops.c:_IO_file_underflow@@GLIBC_2.2.5 [/lib/x86_64-linux-gnu/libc-2.31.so]
   768,432 ( 1.97%)  >   ./libio/genops.c:_IO_switch_to_get_mode (32,018x) [/lib/x86_64-linux-gnu/libc-2.31.so]
   384,216 ( 0.99%)  >   ./libio/fileops.c:_IO_file_read (32,018x) [/lib/x86_64-linux-gnu/libc-2.31.so]
    75,091 ( 0.19%)  >   ./libio/genops.c:_IO_doallocbuf (1x) [/lib/x86_64-linux-gnu/libc-2.31.so]

 1,601,355 ( 4.12%)  *  main.c:addChildBetween [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
14,381,161 (36.96%)  >   ./malloc/malloc.c:malloc (73,360x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   896,504 ( 2.30%)  *  ./libio/genops.c:__uflow [/lib/x86_64-linux-gnu/libc-2.31.so]
 5,069,905 (13.03%)  >   ./libio/genops.c:_IO_default_uflow (32,018x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   768,432 ( 1.97%)  *  ./libio/genops.c:_IO_switch_to_get_mode [/lib/x86_64-linux-gnu/libc-2.31.so]

   704,396 ( 1.81%)  *  ./libio/libioP.h:_IO_file_underflow@@GLIBC_2.2.5

   544,306 ( 1.40%)  *  ./libio/genops.c:_IO_default_uflow [/lib/x86_64-linux-gnu/libc-2.31.so]
 4,301,473 (11.05%)  >   ./libio/fileops.c:_IO_file_underflow@@GLIBC_2.2.5 (32,018x) [/lib/x86_64-linux-gnu/libc-2.31.so]

   504,878 ( 1.30%)  *  main.c:filterDictionary'2 [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
 4,644,912 (11.94%)  >   main.c:filterDictionary'2 (7,838x) [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
   409,653 ( 1.05%)  >   main.c:lowerCounters (6,851x) [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]
   313,573 ( 0.81%)  >   main.c:cutBranch (6,851x) [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]

   409,653 ( 1.05%)  *  main.c:lowerCounters [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]

   330,303 ( 0.85%)  *  main.c:validBranch [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]

   313,573 ( 0.81%)  *  main.c:cutBranch [/mnt/c/Users/Pietro Ammaturo/github/WordChecker/main]

   293,476 ( 0.75%)  *  ./malloc/malloc.c:alloc_perturb [/lib/x86_64-linux-gnu/libc-2.31.so]

   224,126 ( 0.58%)  *  ./io/../sysdeps/unix/sysv/linux/read.c:read [/lib/x86_64-linux-gnu/libc-2.31.so]

   224,126 ( 0.58%)  *  ./libio/libioP.h:_IO_default_uflow

   224,126 ( 0.58%)  *  ./libio/libioP.h:__uflow

   160,090 ( 0.41%)  *  ./libio/fileops.c:_IO_file_read [/lib/x86_64-linux-gnu/libc-2.31.so]
   224,126 ( 0.58%)  >   ./io/../sysdeps/unix/sysv/linux/read.c:read (32,018x) [/lib/x86_64-linux-gnu/libc-2.31.so]

--------------------------------------------------------------------------------
-- Auto-annotated source: main.c
--------------------------------------------------------------------------------
Ir                 

-- line 98 ----------------------------------------
        .           //	utils	//
        .           //////////////
        .           
        .           // - 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z
        .           // 0 1 2 3 4 5 6 7 8 9 101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263
        .           int characterToIndex(char c)
        .           {
        .           	// 11-36
   47,388 ( 0.12%)  	if (c <= 'Z' && c >= 'A')
        .           	{
    7,996 ( 0.02%)  		return c - 'A' + 11;
        .           	}
        .           	// 38-64
   23,610 ( 0.06%)  	else if (c >= 'a' && c <= 'z')
        .           	{
   12,817 ( 0.03%)  		return c - 'a' + 38;
        .           	}
        .           	// 1-10
        .           	else if (c <= '9' && c >= '0')
        .           	{
        .           		return c - '0' + 1;
        .           	}
        .           	// 0
        .           	else if (c == '-')
        .           	{
        8 ( 0.00%)  		return 0;
        .           	}
        .           	// 37
        .           	return 37;
        .           }
        .           _Bool findWord(tree_t *head, char *word, int length)
        .           {
        .           	int i;
        .           	tree_t *treeCursor;
        .           	list_t *rightChild;
        .           
        .           	treeCursor = head;
        .           
        .           	// scorro la parola inserita
      197 ( 0.00%)  	for (i = 0; i < length; i++)
        .           	{
        .           		// trovo il figlio, devo pure aggiornare l'head nel caso cambi
      100 ( 0.00%)  		rightChild = findChild(treeCursor->child, word[i], treeCursor);
        .           		// se lo trovo proseguo la scansione
        .           		if (rightChild)
        .           			// sposto il cursore nel figlio trovato
        .           			treeCursor = rightChild->node;
        .           		else
        .           			// se non lo trovo termino ritornando 0
        1 ( 0.00%)  			return 0;
        .           	}
       18 ( 0.00%)  	return 1;
        1 ( 0.00%)  }
        .           
        .           //////////////
        .           //	alberi	//
        .           //////////////
        .           tree_t *addNode(tree_t *h, char c, int d, tree_t *p)
        8 ( 0.00%)  {
        .           	// adding node
  146,728 ( 0.38%)  	h = (tree_t *)malloc(sizeof(tree_t));
7,189,280 (18.48%)  => ./malloc/malloc.c:malloc (36,680x)
   73,362 ( 0.19%)  	if (h)
        .           	{
   36,681 ( 0.09%)  		h->parent = p;
   36,681 ( 0.09%)  		h->character = c;
   36,681 ( 0.09%)  		h->depth = d;
   73,362 ( 0.19%)  		h->valid = 1;
        .           		h->filtered = 0;
   36,681 ( 0.09%)  		h->child = NULL;
        .           	}
        .           	else
        .           	{
        .           		printf("memory error");
        .           	}
        .           	return h;
        7 ( 0.00%)  }
        .           tree_t *addWord(tree_t *head, char *word, int length)
        .           {
        .           	int i;
        .           	tree_t *treeCursor;
        .           	list_t *rightChild;
        .           
        .           	treeCursor = head;
        .           
        .           	// scorro la parola inserita
  480,000 ( 1.23%)  	for (i = 0; i < length; i++)
        .           	{
        .           		// trovo il figlio o lo aggiungo se non c'è, devo pure aggiornare l'head nel caso cambi
1,120,000 ( 2.88%)  		treeCursor->child = findOrAddChild(treeCursor->child, word[i], i, treeCursor, &rightChild);
24,298,827 (62.45%)  => main.c:findOrAddChild (160,000x)
        .           		// sposto il cursore nel figlio (che sia stato appena aggiunto o meno è indifferente)
  320,000 ( 0.82%)  		treeCursor = rightChild->node;
        .           	}
        .           	return head;
        .           }
        .           tree_t *addWords(tree_t *head, char *word, int length)
       11 ( 0.00%)  {
        .           	// printf("\n----inizio inserimento----\n");
        .           	int i, j;
        .           	char character;
        .           	// prendi primo carattere
        .           	do
        .           	{
       10 ( 0.00%)  		character = getc(stdin);
      204 ( 0.00%)  => ./libio/getc.c:getc (1x)
      663 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        8 ( 0.00%)  	} while (character == EOS || character == EOL || character == EOW);
        .           
        .           	// mentre non ricevo nuovi comandi
   64,006 ( 0.16%)  	for (i = 0; character != '+'; i++)
        .           	{
        .           		// acquisisco la parola al contrario
  768,000 ( 1.97%)  		for (j = 0; j < length; j++)
        .           		{
  160,000 ( 0.41%)  			word[j] = character;
  480,000 ( 1.23%)  			character = getc(stdin);
2,720,000 ( 6.99%)  => ./libio/getc.c:getc (160,000x)
        .           		}
        .           		// la aggiungo al dizionario
        .           		addWord(head, word, length);
        .           		// prendi primo carattere della prossima riga
   96,000 ( 0.25%)  		character = getc(stdin);
6,528,000 (16.78%)  => ./libio/getc.c:getc (32,000x)
        .           	}
        .           	// printf("\n----fine inserimento----\n");
        .           
        .           	return head;
        9 ( 0.00%)  }
        .           // rende valido l'elemento che gli viene passato e tutti i suoi figli
        .           void validBranch(tree_t *h)
        8 ( 0.00%)  {
        .           	list_t *listCursor;
        .           
        .           	// All the children
  220,100 ( 0.57%)  	for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
   36,752 ( 0.09%)  		validBranch(listCursor->node);
        .           
   73,435 ( 0.19%)  	h->valid = 1;
        .           	h->filtered = 0;
        8 ( 0.00%)  }
        .           // rende non filtrato l'elemento che gli viene passato e tutti i suoi figli
        .           void resetFiltered(tree_t *h)
       64 ( 0.00%)  {
        .           	list_t *listCursor;
        .           
        .           	// All the children
   53,761 ( 0.14%)  	for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
   30,018 ( 0.08%)  		if (listCursor->node->filtered)
       16 ( 0.00%)  			resetFiltered(listCursor->node);
   95,968 ( 0.25%)  => main.c:resetFiltered (8x)
        .           
    6,397 ( 0.02%)  	h->filtered = 0;
    6,196 ( 0.02%)  }
        .           // rende non valida la parte di ramo dal nodo dato fino all'ultimo nodo che non ha fratelli validi
        .           
        .           void cutBranch(tree_t *h)
        .           {
        .           	list_t *listCursor;
        .           	listCursor = NULL;
        .           	// rendo non valido il nodo in cui sono
    6,851 ( 0.02%)  	h->valid = 0;
        .           	// scorri mentre il padre è la radice oppure il listcursor è null (il padre non ha figli validi)
   30,395 ( 0.08%)  	while (h->parent->character != EOS && listCursor == NULL)
        .           	{
        .           		// printf("scorro: %c\n", h->character);
        .           		//  scorro finchè non ho raggiunto la fine (NULL) o trovo un valido (il padre ha altri figli validi) DIVERSO dal nodo in cui mi trovo
  274,333 ( 0.71%)  		for (listCursor = h->parent->child; listCursor != NULL && (listCursor->node->valid == 0 || listCursor->node == h); listCursor = listCursor->nextSibiling)
        .           			;
        .           		// vado verso l'alto finchè listCursor è null
        .           		if (listCursor == NULL)
        .           		{
        .           			// vado in alto
        .           			h = h->parent;
        .           			// rendo non validi i nodi mentre salgo
    1,994 ( 0.01%)  			h->valid = 0;
        .           		}
        .           	}
        .           	// printf("radice: %c", h->character);
        .           }
        .           // trova e ritorna l'indirizzo del genitore a profondità più bassa avente solo un figlio
        .           
        .           void lowerCounters(tree_t *h, int *counter)
        .           {
        .           	list_t *listCursor;
        .           	listCursor = NULL;
        .           	// scorri mentre il padre è la radice oppure il listcursor è null (il padre non ha figli validi)
   23,550 ( 0.06%)  	while (h->parent->character != EOS && listCursor == NULL)
        .           	{
        .           		// printf("scorro: %c\n", h->character);
        .           		//  scorro finchè non ho raggiunto la fine (NULL)
        .           		// o trovo un valido non filtrato (il padre ha altri figli validi e non filtrati) DIVERSO dal nodo in cui mi trovo
  288,015 ( 0.74%)  		for (listCursor = h->parent->child; listCursor != NULL && (listCursor->node->valid == 0 || listCursor->node == h || listCursor->node->filtered == 1); listCursor = listCursor->nextSibiling)
        .           			;
        .           		// vado verso l'alto finchè listCursor è null
        .           		if (listCursor == NULL)
        .           		{
        .           			// printf("decremento: %c\n", h->character);
   12,833 ( 0.03%)  			counter[characterToIndex(h->character)]--;
        .           			// vado in alto
        .           			h = h->parent;
        .           		}
        .           	}
        .           	// printf("radice: %c", h->character);
        .           	// printf("decremento1: %c\n", h->character);
   34,255 ( 0.09%)  	counter[characterToIndex(h->character)]--;
    6,851 ( 0.02%)  }
        .           
        .           //////////////
        .           //	liste	//
        .           //////////////
        .           
        .           // unica funzione che aggiunge il figlio se non c'è
        .           // oppure ritorna l'indirizzo del figlio se c'è
        .           list_t *findOrAddChild(list_t *h, char c, int d, tree_t *p, list_t **found)
1,600,000 ( 4.11%)  {
        .           	list_t *cursor, *previous;
        .           	previous = NULL;
        .           	// sposto il cursore fino a trovare il figlio che punta a un nodo il cui carattere è maggiore o uguale di quello desiderato
4,984,030 (12.81%)  	for (cursor = h; cursor != NULL && cursor->node->character < c; cursor = cursor->nextSibiling)
        .           		previous = cursor;
        .           	// se non lo trovo lo aggiungo
  195,521 ( 0.50%)  	if (cursor == NULL || cursor->node->character > c)
        .           	{
  256,760 ( 0.66%)  		cursor = addChildBetween(previous, cursor, c, d, p);
15,982,516 (41.07%)  => main.c:addChildBetween (36,680x)
        .           	}
        .           	// se il precedente è null, ho aggiunto all'inizio della lista cambiando l'head
        .           	if (previous == NULL)
        .           	{
  320,000 ( 0.82%)  		h = cursor;
        .           	}
        .           	// in ogni caso ritorno cursor, se non l' ho aggiunto significa che:
        .           	// cursor != NULL && cursor->node->character == c
  160,000 ( 0.41%)  	*found = cursor;
        .           	return h;
  800,000 ( 2.06%)  }
        .           // aggiunge elemento alla lista tra precedente e prossimo
        .           list_t *addChildBetween(list_t *last, list_t *next, char c, int d, tree_t *p)
  440,160 ( 1.13%)  {
        .           	list_t *newChild;
        .           
  146,720 ( 0.38%)  	newChild = (list_t *)malloc(sizeof(list_t));
7,191,881 (18.48%)  => ./malloc/malloc.c:malloc (36,680x)
        .           	// adding node
   73,360 ( 0.19%)  	if (newChild)
        .           	{
   36,680 ( 0.09%)  		newChild->nextSibiling = next;
   36,680 ( 0.09%)  		newChild->node = addNode(newChild->node, c, d, p);
        .           		// se c'era effettivamente un nodo prima di newChild
   73,360 ( 0.19%)  		if (last)
        .           		{
   24,115 ( 0.06%)  			last->nextSibiling = newChild;
        .           		}
        .           	}
        .           	else
        .           	{
        .           		printf("memory error");
        .           	}
        .           	return newChild;
  330,120 ( 0.85%)  }
        .           // trova e ritorna l'indirizzo del figlio se c'è, altrimenti ritorna null
        .           list_t *findChild(list_t *h, char c, tree_t *p)
        .           {
        .           	list_t *cursor;
        .           	// sposto il cursore fino a trovare il figlio che punta a un nodo il cui carattere è maggiore o uguale di quello desiderato
      982 ( 0.00%)  	for (cursor = h; cursor != NULL && cursor->node->character < c; cursor = cursor->nextSibiling)
        .           		;
        .           	// se non lo trovo ritorno null, non serve scorrerli tutti
       50 ( 0.00%)  	if (cursor == NULL || cursor->node->character > c)
        .           	{
        .           		cursor = NULL;
        .           	}
        .           	// in ogni caso ritorno cursor
        .           	return cursor;
        .           }
        .           ////////////////////
        .           //	CLOSE TO I/O  //
        .           ////////////////////
        .           void filterDictionary(info_t *info, tree_t *h, _Bool *isEnough, int length, int *counter)
   78,570 ( 0.20%)  {
        .           	list_t *listCursor;
        .           	int i, found, characterIndex;
        .           
        .           	// controllo di non essere nell'head
   23,571 ( 0.06%)  	if (h->character != EOS)
        .           	{
    7,848 ( 0.02%)  		characterIndex = characterToIndex(h->character);
    7,848 ( 0.02%)  		h->filtered = 1;
        .           		// inizializzo found che mi serve per stabilire se una lettera ha un numero totale di occorrenze troppo piccolo
    3,344 ( 0.01%)  		found = 0;
        .           		// conto i caratteri
   47,088 ( 0.12%)  		counter[characterIndex]++;
        .           		// se il carattere non si può trovare a quella posizione (profondità)
        .           		// printf("\nchecking position of: %c at: %d, result: %d\n", h->character, h->depth, info->isPositionOfCharacterValid[h->depth][characterToIndex(h->character)]);
   39,240 ( 0.10%)  		if (!(info->isPositionOfCharacterValid[h->depth][characterIndex]))
        .           		{
        .           			// printf("\nwrong position of: %c at: %d\n", h->character, h->depth);
        .           			//    rendo non valido il branch dalla radice morta in giu e decremento i contatori
        .           			//  unValidBranch(findRootOfDeadBranch(h));
   13,702 ( 0.04%)  			cutBranch(h);
  313,573 ( 0.81%)  => main.c:cutBranch (6,851x)
   20,553 ( 0.05%)  			lowerCounters(h, counter);
  409,653 ( 1.05%)  => main.c:lowerCounters (6,851x)
        .           			return;
        .           		}
        .           		// se il numero di una lettera supera il numero effettivo di occorrenze (e si è certi del numero)
   12,123 ( 0.03%)  		else if (counter[characterIndex] > info->discoveredOccurrences[characterIndex] && info->isDefinitive[characterIndex])
        .           		{
        .           			// printf("\nto many of: %c\n", h->character);
        .           			//   rendo non valido il branch dalla radice morta in su e decremento i contatori
        .           			//  unValidBranch(findRootOfDeadBranch(h));
        .           			cutBranch(h);
        .           			lowerCounters(h, counter);
        .           			return;
        .           		}
        .           		// se ho contato abbastanza occorrenze di un carattere
    1,222 ( 0.00%)  		else if (counter[characterIndex] >= info->discoveredOccurrences[characterIndex])
        .           		{
        .           			// segno che non ci sono problemi
    2,669 ( 0.01%)  			isEnough[characterIndex] = 1;
        .           		}
        .           		else
        .           		{
        .           			// segno che ci sono problemi
    2,669 ( 0.01%)  			isEnough[characterIndex] = 0;
        .           		}
    8,007 ( 0.02%)  		if (h->child == NULL)
        .           		{
   31,768 ( 0.08%)  			for (i = 0; i < length; i++)
        .           			{
        .           				// se il numero di una lettera è minore di un minimo trovato
        .           				if (!isEnough[i])
   20,064 ( 0.05%)  					found = 1;
        .           			}
    3,344 ( 0.01%)  			if (found)
        .           			{
        .           				// rendo non valido il branch dalla radice morta in su e decremento i contatori
        .           				// unValidBranch(findRootOfDeadBranch(h));
        .           				cutBranch(h);
        .           				lowerCounters(h, counter);
        .           				return;
        .           			}
        .           			lowerCounters(h, counter);
-- line 430 ----------------------------------------
-- line 448 ----------------------------------------
        .           				cutBranch(h);
        .           				lowerCounters(h, counter);
        .           				return;
        .           			}
        .           			lowerCounters(h, counter);
        .           		}*/
        .           	}
        .           	// All the valid children
   23,748 ( 0.06%)  	for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
   23,712 ( 0.06%)  		if (listCursor->node->valid)
   47,088 ( 0.12%)  			filterDictionary(info, listCursor->node, isEnough, length, counter);
1,228,104 ( 3.16%)  => main.c:filterDictionary'2 (10x)
        .           	;
   40,285 ( 0.10%)  }
        .           void countFiltered(tree_t *h, int *result)
        .           {
        .           	list_t *listCursor;
        .           
       24 ( 0.00%)  	if (h->child == NULL)
        .           		(*result)++;
        .           	else
        .           		// All the children
      192 ( 0.00%)  		for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
      192 ( 0.00%)  			if (listCursor->node->valid)
        4 ( 0.00%)  				countFiltered(listCursor->node, result);
        .           }
        .           
        .           //////////////
        .           //	I/O	    //
        .           //////////////
        .           void printDictionary(tree_t *h, char *word, int length)
        5 ( 0.00%)  {
        .           	list_t *listCursor;
        .           
        .           	// posiziona il carattere nella parola contenitore
        3 ( 0.00%)  	word[h->depth] = h->character;
        .           
        .           	// printf("%c, %d\n", h->character, h->valid);
        .           
        .           	// stampa la parola quando raggiungi la fine
        3 ( 0.00%)  	if (h->child == NULL)
        .           		printf("%.*s\n", length, word);
        .           	else
        .           		// All the children
       24 ( 0.00%)  		for (listCursor = h->child; listCursor != NULL; listCursor = listCursor->nextSibiling)
       24 ( 0.00%)  			if (listCursor->node->valid)
        .           				printDictionary(listCursor->node, word, length);
        4 ( 0.00%)  }
        .           void compareWords(info_t *info, char *word, char *solution, char *result, _Bool *isFree, int length, int *counter)
       72 ( 0.00%)  {
        .           	int i, j, found, definitive, characterIndex;
        .           
      310 ( 0.00%)  	for (i = 0; i < length; i++)
        .           	{
       90 ( 0.00%)  		characterIndex = characterToIndex(word[i]);
      149 ( 0.00%)  		if (word[i] == solution[i])
        .           		{
        .           			// giusta al posto giusto
       16 ( 0.00%)  			result[i] = '+';
        .           			// segno che è già stata associata
       16 ( 0.00%)  			isFree[i] = 0;
        .           			// metto a zero tutti i caratteri (nessuno è valido tranne quello giusto al posto giusto)
        .           			for (j = 0; j < ALPH_LEN; j++)
        .           			{
       96 ( 0.00%)  				info->isPositionOfCharacterValid[i][j] = 0;
        .           			}
        .           			// metto ad 1 quello giusto al posto giusto
       32 ( 0.00%)  			info->isPositionOfCharacterValid[i][characterIndex] = 1;
        .           			// conto la lettera
       16 ( 0.00%)  			counter[characterIndex]++;
        .           		}
        .           		else
        .           		{
        .           			// per ora non è stata trovata
       29 ( 0.00%)  			result[i] = '/';
        .           			// non è associata
       29 ( 0.00%)  			isFree[i] = 1;
        .           			// i caratteri che non sono risultati giusti al posto giusto li rimuovo
       87 ( 0.00%)  			info->isPositionOfCharacterValid[i][characterIndex] = 0;
        .           		}
        .           	}
      189 ( 0.00%)  	for (i = 0; i < length; i++)
        .           	{
       90 ( 0.00%)  		characterIndex = characterToIndex(word[i]);
       90 ( 0.00%)  		definitive = 0;
        .           		found = 0;
      886 ( 0.00%)  		for (j = 0; j < length && !found; j++)
        .           		{
        .           			// controllo se esiste una uguale non associata e non fissata (ancora '/' e non '+')
      514 ( 0.00%)  			if (word[i] == solution[j] && result[i] != '+')
        .           			{
        .           				// se trovo una non associata
       18 ( 0.00%)  				if (isFree[j])
        .           				{
        .           					// trovata, devo passare alla prossima lettera
        .           					// anche per non contare le altre
        .           					found = 1;
        .           					// giusta al posto sbagliato
        7 ( 0.00%)  					result[i] = '|';
        .           					// conto le lettere
       14 ( 0.00%)  					counter[characterIndex]++;
        .           					// segno che è già stata associata
        7 ( 0.00%)  					isFree[j] = 0;
        .           					// se prima pensavo fosse definitiva ho scoperto che non lo è
        .           					definitive = 0;
        .           				}
        .           				// potrei trovare una da associare dopo, ma se non la trovassi avrei le occorrenze definitive
        .           				else
        .           				{
        4 ( 0.00%)  					definitive = 1;
        .           				}
        .           			}
        .           		}
       83 ( 0.00%)  		if (definitive)
        .           		{
        .           			info->discoveredOccurrences[characterIndex] = info->trueOccurrences[characterIndex];
        .           			info->isDefinitive[characterIndex] = 1;
        .           		}
        .           		// controllo se viene trovata
        .           		found = 0;
    1,008 ( 0.00%)  		for (j = 0; j < length && !found; j++)
        .           		{
        .           			// controllo se viene trovata
      252 ( 0.00%)  			if (word[i] == solution[j])
        .           			{
        .           				// segno che è stata trovata e posso uscire dal ciclo
        .           				found = 1;
        .           			}
        .           		}
        .           		// se questo è vero, è proprio sbagliata!!, la rimuovo in toto (da ogni posizione)
       90 ( 0.00%)  		if (!found)
        .           		{
      352 ( 0.00%)  			for (j = 0; j < length; j++)
        .           			{
      264 ( 0.00%)  				info->isPositionOfCharacterValid[j][characterIndex] = 0;
        .           			}
        .           		}
        .           	}
        .           	// aggiorno le occorrenze che non sono già definitive
    1,728 ( 0.00%)  	for (int i = 0; i < ALPH_LEN; i++)
        .           	{
        .           		// se non ho già stabilito il numero definitivo di occorrenze per questa lettera
    1,152 ( 0.00%)  		if (!(info->isDefinitive[i]))
        .           		{
        .           			// non c'è pericolo di contare più occorrenze di quelle massime
        .           			// ogni volta controllo se è stata associata la lettera
    2,304 ( 0.01%)  			if (counter[i] > info->discoveredOccurrences[i])
        .           			{
        6 ( 0.00%)  				info->discoveredOccurrences[i] = counter[i];
        .           			}
        .           		}
        .           	}
        .           	// stampa risultato del confronto
       58 ( 0.00%)  	printf("%.*s\n", length, result);
    4,280 ( 0.01%)  => ./stdio-common/printf.c:printf (8x)
    1,647 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           
        .           	// mostro caratteri che posso trovare alle posizioni
        .           	/*
        .           for (i = 0; i < length; i++)
        .           {
        .           	for (j = 0; j < ALPH_LEN; j++)
        .           		printf("-%d-", info->isPositionOfCharacterValid[i][j]);
        .           	printf("\n");
-- line 608 ----------------------------------------
-- line 626 ----------------------------------------
        .           		printf("\ntrue\n");
        .           		for (i = 0; i < ALPH_LEN; i++)
        .           		{
        .           			printf("%d", info->trueOccurrences[i]);
        .           		}
        .           		printf("\n");
        .           	*/
        .           	return;
       54 ( 0.00%)  }
        .           void startMatch(info_t *info, tree_t *head, char *word, char *solution, char *result, _Bool *isFree, int length)
       28 ( 0.00%)  {
        .           	int i, j, attempts;
        .           	char character;
        .           	char command[MAX_COMMAND_LENGTH];
        .           	int charactersCounter[ALPH_LEN], filteredCounter;
        .           
        .           	//  prendo la soluzione
       44 ( 0.00%)  	for (i = 0; i < length; i++)
       40 ( 0.00%)  		solution[i] = getc(stdin);
      544 ( 0.00%)  => ./libio/getc.c:getc (10x)
        .           	// prendo il null
        6 ( 0.00%)  	character = getc(stdin);
       34 ( 0.00%)  => ./libio/getc.c:getc (2x)
        .           	// scan per sapere quanti tentativi ho a disposizione in questa partita
       12 ( 0.00%)  	if (scanf("%d", &attempts))
    1,542 ( 0.00%)  => ./stdio-common/isoc99_scanf.c:__isoc99_scanf (2x)
        .           		;
        .           	//  prendi primo carattere
        .           	do
        .           	{
       16 ( 0.00%)  		character = getc(stdin);
      442 ( 0.00%)  => ./libio/getc.c:getc (4x)
       16 ( 0.00%)  	} while (character == EOS || character == EOL || character == EOW);
        .           
        .           	// inizializzo i caratteri che posso trovare alle posizioni
        4 ( 0.00%)  	for (i = 0; i < length; i++)
        .           		for (j = 0; j < ALPH_LEN; j++)
       20 ( 0.00%)  			info->isPositionOfCharacterValid[i][j] = 1;
      689 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
       41 ( 0.00%)  => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        .           	// inizializzo il numero di caratteri trovati
        .           	for (i = 0; i < ALPH_LEN; i++)
       14 ( 0.00%)  		info->discoveredOccurrences[i] = 0;
        .           	// inizializzo il numero di caratteri della soluzione
        .           	for (i = 0; i < ALPH_LEN; i++)
        8 ( 0.00%)  		info->trueOccurrences[i] = 0;
        .           	// conto i caratteri della soluzione
       32 ( 0.00%)  	for (i = 0; i < length; i++)
       40 ( 0.00%)  		info->trueOccurrences[characterToIndex(solution[i])]++;
        .           	// inizializzo i definitivi
        .           	for (i = 0; i < ALPH_LEN; i++)
       10 ( 0.00%)  		info->isDefinitive[i] = 0;
        .           
        .           	// le parole provate sono minori del numero di tentativi
        2 ( 0.00%)  	i = 0;
       30 ( 0.00%)  	while (i < attempts)
        .           	{
        .           		// controllo se ho ricevuto comandi durante una partita
       24 ( 0.00%)  		if (character == '+')
        .           		{
        6 ( 0.00%)  			if (fgets(command, MAX_COMMAND_LENGTH, stdin))
      169 ( 0.00%)  => ./libio/iofgets.c:fgets (1x)
        .           				;
        .           			// comando per stampare filtrate durante una partita
        8 ( 0.00%)  			if (strcmp(command, "stampa_filtrate\n") == 0)
        .           			{
        .           				// printf("\n---printing_dictionary---\n");
        5 ( 0.00%)  				printDictionary(head, word, length);
       63 ( 0.00%)  => main.c:printDictionary (1x)
        .           			}
        .           			// comando per aggiungere parole al dizionario durante una partita
        .           			else if (strcmp(command, "inserisci_inizio\n") == 0)
        .           			{
        .           				head = addWords(head, word, length);
        .           				// devo "buttare" la parte finale di comando ("inserisci fine")
        .           				if (fgets(command, MAX_COMMAND_LENGTH, stdin))
        .           					;
-- line 694 ----------------------------------------
-- line 702 ----------------------------------------
        .           					isFree[i] = 0;
        .           				// filtro il dizionario aggiornando i validi
        .           				filterDictionary(info, head, isFree, length, charactersCounter);
        .           			}
        .           		}
        .           		else
        .           		{
        .           			// acquisisco la parola
      210 ( 0.00%)  			for (j = 0; j < length; j++)
        .           			{
       50 ( 0.00%)  				word[j] = character;
      150 ( 0.00%)  				character = getc(stdin);
      850 ( 0.00%)  => ./libio/getc.c:getc (50x)
        .           			}
        .           			// controllo se la parola è presente nel dizionario
       60 ( 0.00%)  			if (findWord(head, word, length))
    1,349 ( 0.00%)  => main.c:findWord (10x)
        .           			{
        .           				// incremento il contatore di tentativi (valgono solo i tentativi validi)
        9 ( 0.00%)  				i++;
       67 ( 0.00%)  				if (strncmp(word, solution, length) == 0)
      715 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      208 ( 0.00%)  => ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2 (8x)
        .           				{
        .           					printf("ok\n");
        .           					validBranch(head);
        .           					return;
        .           				}
        .           				// inizializzo il contatore delle filtrate a zero
        9 ( 0.00%)  				filteredCounter = 0;
        .           				// inizializzo il contatore di caratteri a zero
        .           				for (j = 0; j < ALPH_LEN; j++)
        .           				{
      333 ( 0.00%)  					charactersCounter[j] = 0;
        .           				}
        .           				// inizializzo i free
       27 ( 0.00%)  				for (j = 0; j < length; j++)
        9 ( 0.00%)  					isFree[i] = 0;
        .           				// paragono la parola alla soluzione, stampo il risultato del confronto e aggiorno info
       99 ( 0.00%)  				compareWords(info, word, solution, result, isFree, length, charactersCounter);
   16,573 ( 0.04%)  => main.c:compareWords (9x)
        .           				// inizializzo il contatore di caratteri a zero
        .           				for (j = 0; j < ALPH_LEN; j++)
        .           				{
      324 ( 0.00%)  					charactersCounter[j] = 0;
        .           				}
        .           				// inizializzo i free
       36 ( 0.00%)  				for (j = 0; j < length; j++)
        .           					isFree[i] = 0;
        .           				// resetto i filtered
        .           				resetFiltered(head);
        .           				// filtro il dizionario aggiornando i validi
       54 ( 0.00%)  				filterDictionary(info, head, isFree, length, charactersCounter);
1,228,761 ( 3.16%)  => main.c:filterDictionary (9x)
        .           				// stampa numero di parole rimaste
        .           				countFiltered(head, &filteredCounter);
       48 ( 0.00%)  				printf("%d\n", filteredCounter);
    4,392 ( 0.01%)  => ./stdio-common/printf.c:printf (8x)
        .           			}
        .           			else
        .           			{
        7 ( 0.00%)  				printf("not_exists\n");
      789 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           			}
        .           		}
        .           		// se ho tentativi rimanenti
       21 ( 0.00%)  		if (i < attempts)
        .           			// prendi primo carattere della prossima riga
       27 ( 0.00%)  			character = getc(stdin);
    1,836 ( 0.00%)  => ./libio/getc.c:getc (9x)
        .           	}
        .           	if (i >= attempts)
        .           	{
        .           		// printf("ultimo car: %c\n", character);
        3 ( 0.00%)  		printf("ko\n");
      157 ( 0.00%)  => ./libio/ioputs.c:puts (1x)
        2 ( 0.00%)  		validBranch(head);
  330,303 ( 0.85%)  => main.c:validBranch (1x)
        .           	}
        .           
        .           	return;
        8 ( 0.00%)  }
        .           int main(int argc, char *argv[])
        7 ( 0.00%)  {
        .           	int wordLength;
        .           
        .           	info_t infoVar;
        .           	tree_t *dictionary = NULL;
        .           	char character;
        .           	char *word, *solution, *result;
        .           	_Bool *isFree;
        .           	char command[MAX_COMMAND_LENGTH + 1];
        .           
        .           	// scan per sapere quanto è lunga la parola
        9 ( 0.00%)  	if (scanf("%d", &wordLength))
   76,510 ( 0.20%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
        .           		;
        .           	// creo dizionario vuoto
        7 ( 0.00%)  	dictionary = addNode(dictionary, '\0', (wordLength - 1), NULL);
      862 ( 0.00%)  => main.c:addNode (1x)
        .           
        .           	// creo vettore di vettori statici
        7 ( 0.00%)  	infoVar.isPositionOfCharacterValid = malloc(sizeof(_Bool) * wordLength * ALPH_LEN);
      191 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creating array where to put word
        4 ( 0.00%)  	word = (char *)malloc(sizeof(char) * wordLength);
      189 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creo vettore dove mettere la soluione
        5 ( 0.00%)  	solution = (char *)malloc(sizeof(char) * wordLength);
      189 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creo vettore dove mettere il risultato del confronto
        4 ( 0.00%)  	result = (char *)malloc(sizeof(char) * wordLength);
      189 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           	// creating array where to put check for pairing
        4 ( 0.00%)  	isFree = (_Bool *)malloc(sizeof(_Bool) * wordLength);
      189 ( 0.00%)  => ./malloc/malloc.c:malloc (1x)
        .           
       12 ( 0.00%)  	if (word && solution && result && isFree && infoVar.isPositionOfCharacterValid)
        .           	{
        .           		// aggiungo per la prima volta parole al dizionario
        6 ( 0.00%)  		dictionary = addWords(dictionary, word, wordLength);
37,035,738 (95.18%)  => main.c:addWords (1x)
        .           
        .           		// sicuramente ho terminato con un comando
        .           		// il carattere '+' con cui inizia il comando nuova_partita è stato mangiato da addWords che lo ha "scambiato" per il '+' di inserisci_fine
        .           		character = '+';
        .           		// se non sono in una partita e non sto aggiungendo parole, posso solo ricevere comandi, ma controlliamo ugualmente per sicurezza
        2 ( 0.00%)  		while (character == '+')
        .           		{
       14 ( 0.00%)  			if (fgets(command, MAX_COMMAND_LENGTH, stdin))
      797 ( 0.00%)  => ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave (1x)
      171 ( 0.00%)  => ./libio/iofgets.c:fgets (1x)
        .           				;
        .           			// printf("\ncomando: %s", command);
        .           			//  comando per iniziare una partita
       17 ( 0.00%)  			if (strcmp(command, "nuova_partita\n") == 0)
        .           			{
       26 ( 0.00%)  				startMatch(&infoVar, dictionary, word, solution, result, isFree, wordLength);
1,688,303 ( 4.34%)  => main.c:startMatch (2x)
        .           			}
        .           			// comando per aggiungere parole al dizionario tra una partita e l'altra
        2 ( 0.00%)  			else if (strcmp(command, "inserisci_inizio\n") == 0)
        .           			{
        .           				dictionary = addWords(dictionary, word, wordLength);
        .           				// devo "buttare" la parte finale di comando ("inserisci fine")
        .           				if (fgets(command, MAX_COMMAND_LENGTH, stdin))
        .           					;
        .           			}
        .           			// prendi primo carattere (tendenzialmente sarà un '+'), se non lo è termino l'esecuzione (sarà un \n)
        3 ( 0.00%)  			character = getc(stdin);
      204 ( 0.00%)  => ./libio/getc.c:getc (1x)
        .           		}
        .           	}
        .           	else
        .           	{
        .           		printf("memory error");
        .           	}
        .           
        .           	return 0;
-- line 837 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./io/../sysdeps/unix/sysv/linux/read.c
  ./libio/fileops.c
  ./libio/genops.c
  ./libio/getc.c
  ./libio/libioP.h
  ./malloc/malloc.c

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
15,075,838 (38.74%)  events annotated

